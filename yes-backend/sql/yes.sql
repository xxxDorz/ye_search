/*
 Navicat Premium Data Transfer

 Source Server         : homeTest
 Source Server Type    : MySQL
 Source Server Version : 80030
 Source Host           : localhost:3306
 Source Schema         : yes

 Target Server Type    : MySQL
 Target Server Version : 80030
 File Encoding         : 65001

 Date: 18/04/2023 09:06:19
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for post
-- ----------------------------
DROP TABLE IF EXISTS `post`;
CREATE TABLE `post` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标题',
  `content` text COLLATE utf8mb4_unicode_ci COMMENT '内容',
  `tags` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标签列表（json 数组）',
  `thumbNum` int NOT NULL DEFAULT '0' COMMENT '点赞数',
  `favourNum` int NOT NULL DEFAULT '0' COMMENT '收藏数',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  KEY `idx_userId` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=1645753221097275395 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='帖子';

-- ----------------------------
-- Records of post
-- ----------------------------
BEGIN;
INSERT INTO `post` VALUES (1645612297423745026, 'Java学习', 'Java 是一个通用术语，用于表示 Java 软件及其组件，包括“Java 运行时环境 (JRE)”、“Java 虚拟机 (JVM)”以及“插件”。Java具有大部分编程语言所共有的一些特征，被特意设计用于互联网的分布式环境。Java具有类似于C++语言的形式和感觉，但它要比C++语言更易于使用，而且在编程时彻底采用了一种以对象为导向的方式。', '[\"Java\"]', 0, 1, 1641693136519720961, '2023-04-14 13:33:40', '2023-04-14 13:33:40', 0);
INSERT INTO `post` VALUES (1645647604097556481, 'Maven学习', 'Apache Maven是一个（特别是Java编程）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。', '[\"Maven\"]', 0, 0, 1641693136519720961, '2023-04-11 12:38:58', '2023-04-11 12:38:58', 0);
INSERT INTO `post` VALUES (1645647767281147906, 'Spring学习', 'Spring框架是一个开放源代码的J2EE应用程序框架，由Rod Johnson发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、AOP及Web MVC等功能。Spring可以单独应用于构筑应用程序，也可以和Struts、Webwork、Tapestry等众多Web框架组合使用，并且可以与 Swing等桌面应用程序AP组合。', '[\"Spring\"]', 0, 0, 1641693136519720961, '2023-04-11 12:39:37', '2023-04-11 12:39:37', 0);
INSERT INTO `post` VALUES (1645647947464253441, 'SpringBoot学习', 'Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。', '[\"SpringBoot\"]', 0, 0, 1641693136519720961, '2023-04-11 12:40:19', '2023-04-11 12:40:19', 0);
INSERT INTO `post` VALUES (1645648076929835010, 'Redis学习', 'Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。', '[\"Redis\"]', 0, 0, 1641693136519720961, '2023-04-11 12:40:50', '2023-04-11 12:40:50', 0);
INSERT INTO `post` VALUES (1645648363946057730, '数据结构学习', '数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。', '[\"数据结构\"]', 0, 0, 1641693136519720961, '2023-04-11 12:41:59', '2023-04-11 12:41:59', 0);
INSERT INTO `post` VALUES (1645750599674073090, '浅谈GPT镜像站点构建', '\n\n## 使用API的好处\n\n现在网上越来越多的镜像网站，其实大多都是通过使用[openAI API](https://platform.openai.com/docs/api-reference/chat/create)的GPT3.5模型，18USD免费额度方式部署，通过API的方式访问速度会更快，回复也更快，字数限制也是可控的，比访问官网更加稳定。\n\n其实很多镜像网站使用的也是在github上面开源的，start数较多的项目，像[https://chatbot.theb.ai/](https://chatbot.theb.ai/) 等镜像站点也都是使用的 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web) 开源项目。鱼皮专门分享了一期如何在[github中找项目](https://www.bilibili.com/video/BV1Ki4y1T7Cu/?spm_id_from=333.337.search-card.all.click)，可以帮助我们更加高效找到有用项目\n\n## 本地镜像部署\n\n目前市面上有很多人部署了镜像站点，但是本身是有一定免费额度的，况且GPT4模型可是20刀每月，应该没有这么多慈善家共享出来吧，那么选择部署3.5模型，知识库在2021年也够个人使用了。\n\n项目地址直接用 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web)，文档写的很详细，按着步骤走基本就能正常跑项目，注意次项目是前后端分离项目，也就是你需要启用前端和后端两个服务，进入service文件夹就可以启动后端\n\n重点就是配置env环境变量，只要有了GPT账号就变得简单了：\n\n```js\n// OpenAI API Key - https://platform.openai.com/overview ，请使用自己的KEY\nOPENAI_API_KEY=sk-rrcD2Szetumo22Ehc\n\n// change this to an `accessToken` extracted from the ChatGPT site\'s `https://chat.openai.com/api/auth/session` response\nOPENAI_ACCESS_TOKEN=\n\n// OpenAI API Base URL - https://api.openai.com\nOPENAI_API_BASE_URL=\n\n// OpenAI API Model - https://platform.openai.com/docs/models\nOPENAI_API_MODEL=\n\n// set `true` to disable OpenAI API debug log\nOPENAI_API_DISABLE_DEBUG=\n\n// Reverse Proxy\nAPI_REVERSE_PROXY=https://bypass.churchless.tech/api/conversation\n\n// timeout\nTIMEOUT_MS=100000\n\n// Rate Limit\nMAX_REQUEST_PER_HOUR=\n\n// Secret key\nAUTH_SECRET_KEY=\n\n// Socks Proxy Host\nSOCKS_PROXY_HOST=\n\n// Socks Proxy Port\nSOCKS_PROXY_PORT=\n\n// Socks Proxy Username\nSOCKS_PROXY_USERNAME=\n\n// Socks Proxy Password\nSOCKS_PROXY_PASSWORD=\n\n// HTTPS PROXY | 我使用的Clash，代理端口默认是7890，所以要看你本地代理端口\nHTTPS_PROXY=http://127.0.0.1:7890\n```\n\n如果正确使用了KEY，那么本地就可以访问了。\n\n次项目最重要的应该就是后端接口这一部分，因为前端可以直接在云服务器上部署，但是后端在国内基本是直接部署不了的，需要你像本地一样，使用代理才可以访问。\n\n亦或者使用国外服务器部署，我ping过一些镜像网站，基本公网IP都是在国外.\n\n\n![1.png](https://pic.code-nav.cn/post_picture/1621094259987947521/eex0Aq9f-1.png)\n\n![2.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KD6mroZR-2.png)\n\n所以我就没有选择部署公网了，但是为了使用方便我把前端部署出来了，只需要填写API后端地址就可以在线访问啦！！！\n\n\n![3.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KyIAGJM6-3.png)\n\n## 本地持久化开启服务\n\n当有了前端，没有后端是访问不了的，所以我用了最朴素的方式，就是当我每次打开电脑后就自动开启service服务，那么我就随时可以在本地使用镜像API了，偶尔我还能蹭到别人的后端，因为很多用户用了开源项目就没有修改接口的。\n\n当我们本地可以正常使用的时候，我们只需要做到开机就自动启动服务就好了，我选择了使用`pm2`进行项目守护进程。\n\n在service下进行如下命令：\n\n```bash\n# 全局安装\nnpm install pm2 -g\n# 不用后卸载\nnpm uninstall pm2 -g\n# 如果是linux就可以直接使用\npm2 start npm --name \"my-app-name\" -- start\n# 显然我使用的是windows，所以需要使用下面服务\nnpm install -g pm2-windows-service\n\n# 后端项目进行打包\nnpm run build\n# 后端根目录新建startscript.js ，新增如下内容\nconst cmd = require(\'node-cmd\')\ncmd.run(\'npm run  prod\')\n# 安装node-cmd依赖\nnpm install node-cmd --save\n\n# 安装window服务进程\npm2-service-install -n\n# 使用pm2守护进程\npm2 start startscript.js --name \"my-app-name\" \n```\n\n![4.png](https://pic.code-nav.cn/post_picture/1621094259987947521/k0hRvSAp-4.png)\n\n成功后就可以本地访问了，并且可以通过服务去开启或者关闭进程，不需要每次打开在本地跑项目了！！！\n\n有一点不明白，就是我如果本地直接运行后端就需要开启VPN代理才能访问接口，但是使用了持久化后我关闭了代理，也能够访问~~', '[\"文章\",\"ChatGPT\",\"前端\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:20', 0);
INSERT INTO `post` VALUES (1645750599762153474, 'ThreadLocal：听说你很熟悉我？', '> 基于 JDK1.8\n# ThreadLocal\n`ThreadLocal` 可以用于创建线程本地变量，每个线程使用 `ThreadLocal` 都会拥有自己对该变量的副本，即每个线程都可以独立地改变其副本的值，而不会影响其他线程的副本。\n\n## 数据结构\n`ThreadLocal` 其实就是由内部实现的 `ThreadLocalMap` 组成的，`ThreadLocalMap`  是以 `ThreadLocal` 的**弱引用**作为 `key` ，`value` 为代码中放入的值，每个线程在往 `ThreadLocal` 里放值的时候，都会往自己的 `ThreadLocalMap` 里存，读也是以 `ThreadLocal` 作为引用，在自己的 `map` 里找对应的 `key` ，从而实现了线程隔离。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d20c633ea342d8a052d90ce29cc0eb~tplv-k3u1fbpfcp-watermark.image?)\n\n## ThreadLocalMap\n### 数据结构\nThreadLocalMap 底层就是由 Entry 数组构成\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n\n<p align=center><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9dcea993fd7456bb837f71f9ed5739e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"  /></p>\n\n### ThreadLocalMap.set() 原理解析\n> 源码\n````java\nprivate void set(ThreadLocal<?> key, Object value) {\n    // Entry数组\n    Entry[] tab = table;\n    int len = tab.length;\n    // 获取当前key 的索引位置\n    int i = key.threadLocalHashCode & (len-1);\n    // 以当前 key 对应的 Entry 为起点，遍历 Entry 数组\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        // 当前 Entry 的 key 等于插入值的 key\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        // 当前 Entry 的 key 为 null\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    // 插入元素\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    // 进行启发式清理工作，清除 key 为 null 的数据\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n````\n- 将 `key` 的 `HashCode` 与 `Entry` 数组的长度减一相与获取 `key` 对应的索引位置\n- 根据索引位置获取 `key` 对应的 `Entry`，以该 `Entry` 为起点遍历 `Entry` 数组\n    - 如果当前 `Entry` 为 `null` ，那么直接创建一个新的 `Entry` 插入\n    - 如果当前的 `Entry` 不为 `null`\n        - 如果当前 `Entry` 的 `key` 等于插入值的 `key` ，那么就会替换当前 `Entry` 的 `value` ，然后结束方法。\n        - 如果当前 `Entry` 的 `key` 为 `null` ，说明 `Entry` 是过期数据，执行 `replaceStaleEntry` 方法来替换过期的数据，然后结束方法。\n        - 如果以上两种情况都不符合那么就会获取到下一个 `Entry` 继续判断\n\n- 增加 `Entry` 数组的长度\n- 调用 `cleanSomeSlots` 方法进行启发式清理工作，清理数组中  `Entry` 的 key 为 `null` 的数据，如果 `cleanSomeSlots` 方法未清理任何数据，且当前数组的长度超过了阈值，那么就会调用 `rehash` 方法进行扩容\n\n### ThreadLocalMap.replaceStaleEntry() 原理解析\n> 源码\n\n```java\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    // 待插入元素对应的索引位置\n    int slotToExpunge = staleSlot;\n    // 从待插入元素对应的索引位置开始向前迭代，\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n    // 从待插入元素的索引位置 staleSlot 开始向后迭代\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 相同\n        if (k == key) {\n            e.value = value;\n            // 互换位置\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n            // 清除过期 Entry\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n        // key 为null\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n    // 未找到 key相同的Entry\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n    // 清理过期数据\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n- 从插入值的索引位置 `staleSlot` 开始向前迭代，找到其他过期数据，然后更新过期数据的起始位置 `slotToExpunge`，直到 `Entry` 为 `null`。\n- 从待插入元素的索引位置 `staleSlot` 开始向后迭代\n    - 如果找到了 `key` 相同的 `Entry`  ，则将当前 `Entry` 的值设置为我们插入的值，然后将当前 `Entry` 的位置与待插入元素对应的 `Entry` 位置互换，接着就根据第 1 步获取到的 `slotToExpunge` 开始过期 `Entry` 的处理，最后退出方法。\n    - 如果当前 `Entry` 的 `key` 为 `null`，且过期数据的起始位置 `slotToExpunge` 位于 `staleSlot` ，那么更新 `slotToExpunge` 为当前 `Entry` 的索引位置。\n- 如果在循环中找不到 `key` 相同的 `Entry`，就会创建新的Entry替 换 `table[stableSlot]` 的位置\n- 最后进行过期数据的清理\n\n### ThreadLocalMap.expungeStaleEntry() 原理解析\n> `int staleSlot`：空 slot 的起始位置\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // staleSlot 即为过期 Entry 的起始位置\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    Entry e;\n    int i;\n    // 从起始位置开始向后遍历\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 为null\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        // key 不为 null\n        } else {\n            // 判断位置是否偏离\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                // 位置偏离重新计算位置\n                tab[i] = null;\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n- 将起始位置的 `Entry` 设置为 `null` ，并减小数组中元素的个数。\n- 从起始位置开始向后遍历 `Entry` 数组：\n    - 如果遇到 `key` 为 `null` 的 `Entry` ，那么就把当前的 `Entry` 设置为 `null` ，并且减小数组中元素的个数，然后继续往后探测。\n    - 如果碰到 `key` 不为空的 `Entry` （记作 e ），那么就会重新计算当前 `key` 对应的索引位置（记作 h ），如果与原先的索引位置（也就是当前的 i 值）发生偏离，那么就会将 `i` 对应的 `Entry` 设置为 `null` ，然后重新计算 `e` 的位置。\n    - 如果碰到空的 `slot`  则结束清理，返回空 `slot` 的位置。\n\n### ThreadLocalMap.cleanSomeSlots() 原理解析\n> `int i`：当前 Entry 的位置 <br>\n> `int n`：在插入元素时调用，这个参数代表元素的个数；在 replaceStaleEntry 中调用，这个参数代表数组的长度 。\n``` java\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n- 从当前 Entry 开始向后遍历，遍历 log2(n)  个元素\n- 遇到 key 为null 的Entry 则调用 expungeStaleEntry 进行清理\n\n### ThreadLocalMap 扩容机制\n在set方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值就会执行rehash()\n\n#### rehash 方法\n``` java\nprivate void rehash() {\n    expungeStaleEntries();\n\n    // 数组中的元素个数是否大于 threshold * 3/4\n    if (size >= threshold - threshold / 4)\n        resize();\n}\n```\n- 首先会调用 `expungeStaleEntries` 方法对 `Entry` 数组进行过期数据的清理\n- 然后判断当前数组中的元素个数是否大于 threshold * 3/4 ，如果大于那么就会调用 resize 方法进行扩容\n\n#### resize 方法\n\n``` java\nprivate void resize() {\n    Entry[] oldTab = table;\n    // 旧容量\n    int oldLen = oldTab.length;\n    // 新容量\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n    for (Entry e : oldTab) {\n        if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n            } else {\n                // 重新计算hash\n                int h = k.threadLocalHashCode & (newLen - 1);\n                // hash 冲突则往后查找\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                newTab[h] = e;\n                count++;\n            }\n        }\n    }\n    // 重新计算扩容阈值\n    setThreshold(newLen);\n    size = count;\n    table = newTab;\n}\n```\n- 扩容后的 `Entry` 数组的长度变为旧容量的 `2` 倍\n- 然后去遍历旧的 `Entry` 数组，重新计算 `hash` 位置，然后放到新的 `Entry` 数组中，如果出现 `hash` 冲突则往后寻找最近的 `Entry` 为 `null` 的槽位，遍历完成之后，旧数组中所有的 `Entry` 数据都已经放入到新的 `Entry` 数组中。最后重新计算数组的扩容阈值。\n\n### ThreadLocalMap.getEntry() 原理解析\n> `ThreadLocal<?> key` ：当前key\n```java\nprivate Entry getEntry(ThreadLocal<?> key) {\n    // 获取索引\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    // 命中则直接返回\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n根据 `key` 的 `hash` 获取对应的 `Entry`，如果当前 `Entry` 的 `key` 等于查找的 `key` 那就返回当前 `Entry`，否则就调用 `getEntryAfterMiss` 方法。\n\n### ThreadLocalMap.getEntryAfterMiss() 原理解析\n当 `key` 在其直接哈希槽中找不到时使用\n> `ThreadLocal<?> key` : ThreadLocal 对象 <br>\n> `int i` : ThreadLocal 对应的 hash 值 <br>\n> `Entry e` : ThreadLocal 对应的 Entry\n``` java\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n- 如果当前 `key` 对应的 `Entry` 不为空\n    - 判断当前 `Entry` 的 `key` 是否等于获取的 `key` ，是的话那么就返回当前的 `Entry`。\n    - 如果当前 `Entry` 的 `key` 为 `null` 那么就会调用 `expungeStaleEntry` 方法来清理，接着继续往后迭代。\n- 如果当前 `key` 对应的 `Entry` 为空就直接返回 `null`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '[\"文章\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:22', 0);
INSERT INTO `post` VALUES (1645750599770542081, 'C++ 学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"C++\",\"教程\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:22', 0);
INSERT INTO `post` VALUES (1645750599774736385, '数据库学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"数据库\",\"教程\",\"MySQL\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:23', 0);
INSERT INTO `post` VALUES (1645750599774736386, '小程序开发学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"小程序\",\"教程\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:24', 0);
INSERT INTO `post` VALUES (1645750599783124994, '计算机基础学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"计算机基础\",\"教程\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:24', 0);
INSERT INTO `post` VALUES (1645750599783124995, '软件工程学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"软件开发\",\"教程\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:25', 0);
INSERT INTO `post` VALUES (1645750599787319297, '企业项目研发流程', '大家好，我是鱼皮。\n\n很多未工作过的小伙伴都很好奇：企业中做项目是怎样的流程？尤其是大厂那些百万用户的项目，和自己学编程时做项目到底有什么区别呢？\n\n**实话说，区别可大了！**\n\n自己开发项目那是单打独斗，自己掌握命运，不会拖垮队友；但企业中开发项目是开团打本，大家是一根绳上的蚂蚱，每个人都会影响整个项目。\n\n![](https://qiniuyun.code-nav.cn/image-20210712012036685.png)\n\n我自己也在几家公司实习过，不得不说，大厂和其他公司的研发流程也有很大的区别。\n\n因此，对于大多数同学，如果没有在大厂工作过，对很多研发环节可能都是一无所知的。\n\n所以今天给大家揭秘一下大厂的项目研发流程，帮大家开拓思路。\n\n正好之前有同志质疑我的日常工作就只有写代码和摸鱼？！这篇文章就作为回击，让他明白，在大厂做项目，可不止写代码那么简单！\n\n![](https://qiniuyun.code-nav.cn/image-20210712011545940.png)\n\n注意：这篇文章更侧重于理论知识，鱼皮曾经在星球直播带大家以实践的方式系统学习团队合作开发项目的方法，保证大家都能上线自己的项目，可以看下 [星球项目训练营](https://t.zsxq.com/0cg8VKgdC) 。如果还未加入星球，欢迎 [加入编程导航知识星球](https://yupi.icu/) 。\n\n本文视频版：https://www.bilibili.com/video/BV11q4y1T7kY\n\n\n\n## 大厂研发流程揭秘\n\n为了规范团队、保证项目的进展，大厂研发流程通常还是比较复杂的。\n\n可以分为很多个阶段，用一张思维导图来概括：\n\n![一线大厂研发流程导图](https://qiniuyun.code-nav.cn/%E4%B8%80%E7%BA%BF%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E6%8F%AD%E7%A7%98.png)\n\n> 需要注意的是，以上阶段并不是完全按从上到下的顺序执行，阶段间可能存在交叉，比如 **技术选型** 其实在 **设计阶段** 就应该考虑。\n\n\n\n正式工作一年多，我也是经历过多次项目的完整研发流程的。下面就以我的视角，带大家快速过一遍~\n\n（为了内容更有趣，以下故事有虚构成分）\n\n\n\n### 需求阶段\n\n今天是周一，鱼皮像往常一样骑着他的小电动车来到公司，殊不知，等待他的是一场噩梦的开始。\n\n\n\n#### 需求产生\n\n上午十点，产品妹子找到鱼皮，告诉他：咱们的系统上线后，用户表示很多功能并不好用，需要大改。\n\n老板也找到鱼皮，告诉他：我今天打开页面竟然加载了十几秒，咱们这个系统的性能太烂了吧！\n\n鱼皮心想：呕豁，完蛋！估计得做个新的项目了，又要开会了。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141645333.png)\n\n果然，没过多久，屏幕上弹出了一条 “欢迎加入会议” 的邀请。\n\n\n\n#### 需求评审\n\n第二天上午，老板、产品、测试、几位开发大哥和鱼皮一起来到会议室，具体讨论昨天提到的那些需求 **是否合理、要不要做** ？\n\n产品妹子打开文档，说到：这一期呢，我们要做这几个需求，下面我来详细讲一下，大家一起评估下有没有问题。\n\n\n\n#### 需求分析\n\n接下来，产品妹子正在对着屏幕侃侃而谈、疯狂输出时，旁边的开发大哥坐不住了。\n\n开发大哥：这个需求不合理啊！\n\n产品：为啥不合理？用户就是有这个需求啊！\n\n开发大哥：我知道，实现不了啊！\n\n于是开始了经典的产品开发撕逼大战。。。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141444097.png)\n\n而鱼皮正躲在角落冷静分析 **这个需求怎么做** ，过了一会儿，提出了一种改动低、实现快的解决方案，平息了这场战争。\n\n\n\n#### 排期\n\n确定需求合理、可实现之后，产品妹子问到：那这个需求啥时候能上线呀？\n\n开发大哥：我这周忙，下周吧。\n\n产品：用户可能比较着急，这周就要呢！\n\n开发大哥：我知道，做不完啊！\n\n于是开始了经典的产品开发撕逼大战。。。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141336633.png)\n\n鱼皮：要不我们把这个需求拆解为功能 A 和功能 B，这周我先把功能 A 做了，功能 B 排到下周二测试，下周四上线？\n\n就这样，我们一个个安排了需求的计划完成日期。\n\n\n\n### 设计阶段\n\n终于开完会了，看了下时间，都该下班了！\n\n唉，需求讨论完了，产品的工作是完成了一些，可鱼皮的工作才刚刚开始。\n\n急着开始写代码么？\n\n**不，想好怎么写代码比写代码更重要。**\n\n\n\n#### 架构设计\n\n鱼皮打开写文档软件和画图软件，开始梳理整个系统，从整体到局部，依次设计出系统的层次结构、各层间交互的接口和通讯方式、每层之间包含哪些重要模块、模块选择何种物理部署方式等。\n\n![知名框架 Dubbo 的架构设计](https://qiniuyun.code-nav.cn/693275-20180308155215280-770422402.png)\n\n\n\n#### 概要设计\n\n写完架构设计后，鱼皮开始对着产品妹子写的 PRD（产品需求文档），分析需求，然后依然是从整体到局部，先整理出系统需要的功能模块，再分析每个功能模块内有哪些子模块。\n\n和抽象的架构设计相比，概要设计和需求的关系更紧密，是对架构设计的细化。\n\n打个比方大家就明白了，你要盖一栋楼，架构设计就是从整体来考虑，总共有几层、每层管道怎么接、每层有几户、地基怎么打等；而概要设计就是考虑每户套件的内部怎么划分，哪里是客厅、哪里是卫生间。\n\n\n\n> 很多情况下，概要设计和架构设计可能会在一个文档中进行，划分并不明确。\n\n\n\n#### 详细设计\n\n想好系统有哪些功能后，鱼皮就开始具体分析每个功能如何实现，用到哪些算法、需要注重哪些细节等。\n\n\n\n#### 方案对齐\n\n写好设计文档后，下次会议上，鱼皮和其他的开发同学（前端、后端等）一起针对自己设计的方案展开讨论，最终产生一个统一的方案，然后大家分工去做就好了。\n\n\n\n#### 测试用例设计\n\n为了保证系统功能的正常稳定，测试同学（或者叫 QA）是非常重要的，测试不是像我们自己做项目一样对着网页点几下就 ok 了。\n\n在大公司中，为了保证测试的覆盖度、提高测试效率，一般是要设计测试用例的，比如：用户点击 “登录”，未传任何数据，期望结果是警告用户输入用户名和密码。\n\n![测试用例管理](https://qiniuyun.code-nav.cn/product-content-testcase-1X3-12439a68c4.png)\n\n测试用例设计完后，需要其他同学一起来评审把关，而不是只交给测试同学。因为一个人很容易忽略掉很多测试细节，最好让更熟悉代码的开发同学一起帮忙补充。\n\n鱼皮自己也写了几个测试可能会遗漏的用例，和测试同学一起进行了确认，尽量让问题暴露在测试阶段而不是线上。\n\n\n\n### 研发准备\n\n写了快一周的设计文档，终于准备开始动手搭建项目了。但在此之前，还有一些准备工作要进行。\n\n\n\n#### 技术预研\n\n如今技术发展太快，新技术层出不穷，所以鱼皮首先对项目中需要或可能需要用到的技术进行了调研。\n\n\n\n#### 技术选型\n\n通过调研，鱼皮得到了几个可以满足需求的技术，但他开始纠结：这么多技术，我该用哪一个呢？是用 SSM 框架还是 Play 框架呢？用 guava 包还是 Apache Commons 呢？\n\n鱼皮又打开了写文档软件，开始对比不同技术的优劣，头疼啊，技术选型要考量的因素太多了，比如：\n\n- 单从技术考虑：性能、易用性、稳定性、主流程度和生态、文档详细度\n- 结合团队：团队成员对技术的熟悉度、掌控度（有无精通该技术的人）\n- 结合业务：是否适应业务的量级（单机 or 微服务）、是否适应业务（读多、写多 or 分析多）\n\n\n\n对于关键的项目，鱼皮自己还不敢完全确定选型，因此在写好自己的选型文档后，与同事和 Leader 一起讨论，才最终确认。\n\n\n\n#### 资源申请\n\n确认好技术后，就要申请资源。比如鱼皮用到了 MySQL 数据库，但是这个 MySQL 从哪儿来呢？\n\n以前的话，鱼皮都是去买一台云服务器，自己搭建 MySQL。但是在企业中，一般是有集中管理和分配资源的平台的，直接到平台填写预算、等领导审批、然后等着下发资源就好了。千万不能私自用自己的或买外部的服务器来部署项目，不安全！\n\n鱼皮这次直接申请到了 2 万多一年的云数据库，真的是爽死了。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140804895.png)\n\n\n\n#### 环境准备\n\n申请好数据库等资源后，鱼皮按照申请机器的版本搭建了一模一样的本地开发环境和测试环境，后面就可以直接连接了。\n\n\n\n#### 项目初始化\n\n环境准备妥当后，由于是新项目，鱼皮要搞一个最小可运行的初始化项目 Demo，使用 **脚手架** 自动生成代码，而不是从零开始一个个新建文件、手敲重复代码。\n\n\n\n#### 依赖安装\n\n生成了项目代码后，鱼皮使用包管理工具（前端 yarn、Java Maven /  Gradle 等）自动安装依赖，然后项目 Demo 就可以运行啦！\n\n\n\n### 研发阶段\n\n前期准备完成后，这才到了程序员朋友们最熟悉的写代码环节，也是鱼皮最爱的环节。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140724830.png)\n\n因为之前设计方案时需要保持冷静、仔细思考，没法边听歌儿边做；而方案设计好后，已经明确了该怎么做，写代码实现就很简单了，顶多是遇到一些坑，上网搜索去解决就好了。\n\n\n\n#### 本地开发\n\n开发时，一般鱼皮会先在本地写代码，通过配置热更新工具，实现代码更新时自动重新编译打包，而不用手动重启项目，大大提高了开发效率。\n\n对了，企业开发都会使用版本控制系统的，比如 Git，开发前记得先创建一个自己的分支，在这个分支上开发。\n\n\n\n#### 远程开发\n\n现在还有一种比较流行的远程开发方式，就是可以像编辑本地文件一样编辑远程文件，直接修改服务器上的代码。一般我们每位研发同学是有自己的开发机的，通过远程开发就省去了反复部署调试的麻烦，提高效率。一般用 VSCode 等开发工具，安装远程开发插件就可以实现了。\n\n\n\n#### 代码优化\n\n鱼皮在写代码的时候，始终保持主动优化代码的好习惯，注重代码的时空复杂度；并且当重复代码多了，会想办法抽象成函数或者使用设计模式。之前专门写文章分享过我的编程习惯：[我写代码时的小倔强](https://mp.weixin.qq.com/s/df5JMmBbw294y2sAPMwGbA) 。\n\n\n\n#### 单元测试\n\n注意！不要听到测试就以为是测试同学的工作，开发同学也同样需要编写小粒度的测试来为自己的代码负责。\n\n鱼皮一般会为每个数据库读写函数和业务逻辑函数编写单元测试，像 Java 的话一般用 JUnit 等工具，还可以用 Jacoco 生成测试覆盖度报告。每次修改关键代码后，都要执行一遍单元测试，防止意外错误。\n\n![Jacoco 测试覆盖度报告](https://qiniuyun.code-nav.cn/image-20210712140554038.png)\n\n\n\n#### 开发联调\n\n鱼皮终于写好了后端代码，也自测完成了，下面就是把写好的代码打包构建，然后把可执行项目包发布到测试服务器上，和前端同学一起联调，让他请求我的接口，验证系统的功能是否可用。\n\n\n\n### 测试验证\n\n鱼皮和前端联调完毕后，告知了测试和产品同学。\n\n测试验证是企业中至关重要的环节，甚至可以说是最后一道防线。测试的目的是找 Bug，尽量发现系统中的问题，把它们扼杀在测试阶段。\n\n在企业中，测试验证又有很多类型。\n\n\n\n#### 集成测试\n\n集成测试比单元测试粒度更大，是把多个模块或代码单元放在一起，验证模块之间的集成和调用关系。\n\n因为单个函数的执行可能是正常的，但把多个函数组合在一起顺序调用，可能就会出现问题。\n\n打个比方，我们有个吃面包系统：\n\n功能 A：小鱼吃一个面包\n\n功能 B：小皮吃一个面包\n\n每次只有一个面包，独立执行功能 A 和 B 都是允许的。但如果两个一起执行，后执行的那个功能就会报错。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140428508.png)\n\n\n\n#### 系统测试\n\n系统测试比集成测试的粒度更大，测试对象是整个系统，不仅包括软件，还可能覆盖对硬件的测试。\n\n\n\n#### 产品体验\n\n除了测试同学要验证系统可用性，产品妹子也要体验下功能是否符合预期、是否易用。大多数情况下，产品会在体验时提出修改建议，开发可能还要再去做一些修改。\n\n\n\n#### 验收测试\n\n测试和产品妹子终于表示没有问题啦，那就到了最后一步，把整个产品或功能给最终的用户来体验。~~老板~~ 用户说没问题，才是真的没问题！\n\n\n\n### 提交阶段\n\n系统没问题之后，鱼皮就可以把代码发布到远程仓库了，一般使用 Git 和 SVN 等版本控制系统。\n\n\n\n#### 代码提交\n\n鱼皮首先在本地触发代码提交（git commit），为保证规范，在大项目中一般会使用提交检测插件，防止你把错误的代码进行了提交。\n\n\n\n#### 代码推送\n\n下一步就是把本地的提交推送到远程的同名分支。一般大厂会有推送检测工具，检测代码的错误、圈复杂度、代码规范等，和提交检测一样，防止你把错误或不规范的代码进行了推送。\n\n\n\n#### 合并请求\n\n代码分支推送到远程之后，鱼皮发起了一个分支合并请求（MR），希望把该分支的代码合并到主干分支（没问题的代码）。\n\n![发起新合并请求](https://qiniuyun.code-nav.cn/image-20210712140308463.png)\n\n#### 代码审查\n\n并不是发起了合并请求就能直接合并，还要通过代码审查，即 CR。\n\n审查又分为两种方式：人审和机审。\n\n相信不少同学都知道人审，一般是由你的上级和其他项目负责人来阅读和评论你的代码，觉得没问题就 Approve（通过），否则打回去修改。\n\n那机审是个啥呢？其实就是机器自动检测你的代码是否符合规范，是否能够成功自动化构建等，一般是由项目负责人配置的，可以帮助发现一些人工难以发现的问题。\n\n刚接触新项目的时候，鱼皮经常被机审折磨得苦不堪言，经常被提示一些莫名其妙的代码问题，比如加号要换行，文件行末要加空行等。但后来注意编码习惯后，就很自然地适应了，的确不错。\n\n\n\n### 发布阶段\n\n代码审查通过后，鱼皮的项目代码就可以发布上线啦。\n\n![](https://qiniuyun.code-nav.cn/image-20210613143744811.png)\n\n\n\n#### 打包构建\n\n传统上线方式是开发人员到正式服务器上拉取代码，然后安装依赖，再通过工具把代码打包构建，得到部署包，通过 Nginx、Tomcat、Docker 等技术运行。\n\n但这样效率很低，有很多重复工作。所以大厂一般是用自动化构建的，像 Jenkins、各种 CI / CD 工具等。代码合并到主分之后，由机器把代码打包构建为最终的部署包。\n\n\n\n#### 预发布\n\n为了防止上线出问题，一般我们会先在预发布环境部署项目，再观察一下是否能够正常运行。\n\n\n\n#### 正式发布\n\n预发布测试正常后，鱼皮终于等到了上线的这一刻。大项目一般都会部署在多台机器上，所以不可能一台台登录机器去发布部署包。\n\n通常公司会提供可视化发布平台，点选需要发布机器（一般先灰度，选一小部分机器，再全量发布），点击一键发布，等项目管理员审批通过之后，就交给机器自动部署吧！\n\n\n\n### 后续\n\n鱼皮曾天真地以为项目上线之后，就可以高枕无忧了。但后来发现，项目上线之后，同样需要保持警觉。虽然已经测试过，但仍然时不时会出现个预期之外的小 Bug，还是很考验心态的。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140135097.png)\n\n来看看上线之后，鱼皮做了哪些事呢？\n\n\n\n#### 监控运维\n\n鱼皮会定期查看项目的监控面板，观察项目的运行情况，机器的负载等。\n\n\n\n#### 统计分析\n\n鱼皮在代码中添加了一些日志，可以利用 ELK 等日志收集可视化平台对这些日志进行分析，从而感知到用户的行为，进一步优化业务和系统。\n\n比如我会统计用户执行 SQL 查询的耗时，对重复率高的慢 SQL 进行针对性地优化。\n\n\n\n#### 事件反馈\n\n有的时候，用户自己都不能清楚地描述 Bug，而且历史 Bug 也不方便找到。所以公司内部一般会有事件反馈平台，产品等内部同学在接收到 Bug 时，会在该平台发布一个 Bug 事件，详细描述 Bug 出现的时间、状况、详情等，便于我们开发集中分析和处理问题。\n\n![事件反馈平台](https://qiniuyun.code-nav.cn/image-20210712140028393.png)\n\n\n\n#### 文档沉淀\n\n每次上线了新功能和项目，鱼皮都会通过写文档来记录项目的背景、设计方案、开发过程和一些坑点，便于后续其他同学了解项目，这是非常重要的！利人利己。\n\n曾经分享过我的写文档技巧：[如何写好文档？](https://mp.weixin.qq.com/s/oQTksFE-cPYRKGJnr71-kw)\n\n\n\n#### 迭代优化\n\n最后，一个需求的结束往往只是另一个需求的开始。像鱼皮最近在跟进的项目，一期做完做二期，二期还没做完三期就来了；还要抽出时间去优化以前的代码，这日子遥遥无期，没盼头啊！\n\n\n\n---\n\n\n\n看完本文后，欢迎阅读我之前的这篇文章：[大厂机密！30 个提升团队研发效能的锦囊](https://mp.weixin.qq.com/s/RyqO8ry29zAL40ToVitxTQ) ，了解更多大厂技术。\n\n', '[\"文章\",\"学习路线\",\"软件开发\",\"教程\"]', 0, 0, 1641693136519720961, '2023-04-11 19:28:14', '2023-04-11 19:34:29', 0);
INSERT INTO `post` VALUES (1645753221021777921, '浅谈GPT镜像站点构建', '\n\n## 使用API的好处\n\n现在网上越来越多的镜像网站，其实大多都是通过使用[openAI API](https://platform.openai.com/docs/api-reference/chat/create)的GPT3.5模型，18USD免费额度方式部署，通过API的方式访问速度会更快，回复也更快，字数限制也是可控的，比访问官网更加稳定。\n\n其实很多镜像网站使用的也是在github上面开源的，start数较多的项目，像[https://chatbot.theb.ai/](https://chatbot.theb.ai/) 等镜像站点也都是使用的 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web) 开源项目。鱼皮专门分享了一期如何在[github中找项目](https://www.bilibili.com/video/BV1Ki4y1T7Cu/?spm_id_from=333.337.search-card.all.click)，可以帮助我们更加高效找到有用项目\n\n## 本地镜像部署\n\n目前市面上有很多人部署了镜像站点，但是本身是有一定免费额度的，况且GPT4模型可是20刀每月，应该没有这么多慈善家共享出来吧，那么选择部署3.5模型，知识库在2021年也够个人使用了。\n\n项目地址直接用 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web)，文档写的很详细，按着步骤走基本就能正常跑项目，注意次项目是前后端分离项目，也就是你需要启用前端和后端两个服务，进入service文件夹就可以启动后端\n\n重点就是配置env环境变量，只要有了GPT账号就变得简单了：\n\n```js\n// OpenAI API Key - https://platform.openai.com/overview ，请使用自己的KEY\nOPENAI_API_KEY=sk-rrcD2Szetumo22Ehc\n\n// change this to an `accessToken` extracted from the ChatGPT site\'s `https://chat.openai.com/api/auth/session` response\nOPENAI_ACCESS_TOKEN=\n\n// OpenAI API Base URL - https://api.openai.com\nOPENAI_API_BASE_URL=\n\n// OpenAI API Model - https://platform.openai.com/docs/models\nOPENAI_API_MODEL=\n\n// set `true` to disable OpenAI API debug log\nOPENAI_API_DISABLE_DEBUG=\n\n// Reverse Proxy\nAPI_REVERSE_PROXY=https://bypass.churchless.tech/api/conversation\n\n// timeout\nTIMEOUT_MS=100000\n\n// Rate Limit\nMAX_REQUEST_PER_HOUR=\n\n// Secret key\nAUTH_SECRET_KEY=\n\n// Socks Proxy Host\nSOCKS_PROXY_HOST=\n\n// Socks Proxy Port\nSOCKS_PROXY_PORT=\n\n// Socks Proxy Username\nSOCKS_PROXY_USERNAME=\n\n// Socks Proxy Password\nSOCKS_PROXY_PASSWORD=\n\n// HTTPS PROXY | 我使用的Clash，代理端口默认是7890，所以要看你本地代理端口\nHTTPS_PROXY=http://127.0.0.1:7890\n```\n\n如果正确使用了KEY，那么本地就可以访问了。\n\n次项目最重要的应该就是后端接口这一部分，因为前端可以直接在云服务器上部署，但是后端在国内基本是直接部署不了的，需要你像本地一样，使用代理才可以访问。\n\n亦或者使用国外服务器部署，我ping过一些镜像网站，基本公网IP都是在国外.\n\n\n![1.png](https://pic.code-nav.cn/post_picture/1621094259987947521/eex0Aq9f-1.png)\n\n![2.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KD6mroZR-2.png)\n\n所以我就没有选择部署公网了，但是为了使用方便我把前端部署出来了，只需要填写API后端地址就可以在线访问啦！！！\n\n\n![3.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KyIAGJM6-3.png)\n\n## 本地持久化开启服务\n\n当有了前端，没有后端是访问不了的，所以我用了最朴素的方式，就是当我每次打开电脑后就自动开启service服务，那么我就随时可以在本地使用镜像API了，偶尔我还能蹭到别人的后端，因为很多用户用了开源项目就没有修改接口的。\n\n当我们本地可以正常使用的时候，我们只需要做到开机就自动启动服务就好了，我选择了使用`pm2`进行项目守护进程。\n\n在service下进行如下命令：\n\n```bash\n# 全局安装\nnpm install pm2 -g\n# 不用后卸载\nnpm uninstall pm2 -g\n# 如果是linux就可以直接使用\npm2 start npm --name \"my-app-name\" -- start\n# 显然我使用的是windows，所以需要使用下面服务\nnpm install -g pm2-windows-service\n\n# 后端项目进行打包\nnpm run build\n# 后端根目录新建startscript.js ，新增如下内容\nconst cmd = require(\'node-cmd\')\ncmd.run(\'npm run  prod\')\n# 安装node-cmd依赖\nnpm install node-cmd --save\n\n# 安装window服务进程\npm2-service-install -n\n# 使用pm2守护进程\npm2 start startscript.js --name \"my-app-name\" \n```\n\n![4.png](https://pic.code-nav.cn/post_picture/1621094259987947521/k0hRvSAp-4.png)\n\n成功后就可以本地访问了，并且可以通过服务去开启或者关闭进程，不需要每次打开在本地跑项目了！！！\n\n有一点不明白，就是我如果本地直接运行后端就需要开启VPN代理才能访问接口，但是使用了持久化后我关闭了代理，也能够访问~~', '[\"文章\",\"ChatGPT\",\"前端\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221084692482, 'ThreadLocal：听说你很熟悉我？', '> 基于 JDK1.8\n# ThreadLocal\n`ThreadLocal` 可以用于创建线程本地变量，每个线程使用 `ThreadLocal` 都会拥有自己对该变量的副本，即每个线程都可以独立地改变其副本的值，而不会影响其他线程的副本。\n\n## 数据结构\n`ThreadLocal` 其实就是由内部实现的 `ThreadLocalMap` 组成的，`ThreadLocalMap`  是以 `ThreadLocal` 的**弱引用**作为 `key` ，`value` 为代码中放入的值，每个线程在往 `ThreadLocal` 里放值的时候，都会往自己的 `ThreadLocalMap` 里存，读也是以 `ThreadLocal` 作为引用，在自己的 `map` 里找对应的 `key` ，从而实现了线程隔离。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d20c633ea342d8a052d90ce29cc0eb~tplv-k3u1fbpfcp-watermark.image?)\n\n## ThreadLocalMap\n### 数据结构\nThreadLocalMap 底层就是由 Entry 数组构成\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n\n<p align=center><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9dcea993fd7456bb837f71f9ed5739e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"  /></p>\n\n### ThreadLocalMap.set() 原理解析\n> 源码\n````java\nprivate void set(ThreadLocal<?> key, Object value) {\n    // Entry数组\n    Entry[] tab = table;\n    int len = tab.length;\n    // 获取当前key 的索引位置\n    int i = key.threadLocalHashCode & (len-1);\n    // 以当前 key 对应的 Entry 为起点，遍历 Entry 数组\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        // 当前 Entry 的 key 等于插入值的 key\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        // 当前 Entry 的 key 为 null\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    // 插入元素\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    // 进行启发式清理工作，清除 key 为 null 的数据\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n````\n- 将 `key` 的 `HashCode` 与 `Entry` 数组的长度减一相与获取 `key` 对应的索引位置\n- 根据索引位置获取 `key` 对应的 `Entry`，以该 `Entry` 为起点遍历 `Entry` 数组\n    - 如果当前 `Entry` 为 `null` ，那么直接创建一个新的 `Entry` 插入\n    - 如果当前的 `Entry` 不为 `null`\n        - 如果当前 `Entry` 的 `key` 等于插入值的 `key` ，那么就会替换当前 `Entry` 的 `value` ，然后结束方法。\n        - 如果当前 `Entry` 的 `key` 为 `null` ，说明 `Entry` 是过期数据，执行 `replaceStaleEntry` 方法来替换过期的数据，然后结束方法。\n        - 如果以上两种情况都不符合那么就会获取到下一个 `Entry` 继续判断\n\n- 增加 `Entry` 数组的长度\n- 调用 `cleanSomeSlots` 方法进行启发式清理工作，清理数组中  `Entry` 的 key 为 `null` 的数据，如果 `cleanSomeSlots` 方法未清理任何数据，且当前数组的长度超过了阈值，那么就会调用 `rehash` 方法进行扩容\n\n### ThreadLocalMap.replaceStaleEntry() 原理解析\n> 源码\n\n```java\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    // 待插入元素对应的索引位置\n    int slotToExpunge = staleSlot;\n    // 从待插入元素对应的索引位置开始向前迭代，\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n    // 从待插入元素的索引位置 staleSlot 开始向后迭代\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 相同\n        if (k == key) {\n            e.value = value;\n            // 互换位置\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n            // 清除过期 Entry\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n        // key 为null\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n    // 未找到 key相同的Entry\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n    // 清理过期数据\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n- 从插入值的索引位置 `staleSlot` 开始向前迭代，找到其他过期数据，然后更新过期数据的起始位置 `slotToExpunge`，直到 `Entry` 为 `null`。\n- 从待插入元素的索引位置 `staleSlot` 开始向后迭代\n    - 如果找到了 `key` 相同的 `Entry`  ，则将当前 `Entry` 的值设置为我们插入的值，然后将当前 `Entry` 的位置与待插入元素对应的 `Entry` 位置互换，接着就根据第 1 步获取到的 `slotToExpunge` 开始过期 `Entry` 的处理，最后退出方法。\n    - 如果当前 `Entry` 的 `key` 为 `null`，且过期数据的起始位置 `slotToExpunge` 位于 `staleSlot` ，那么更新 `slotToExpunge` 为当前 `Entry` 的索引位置。\n- 如果在循环中找不到 `key` 相同的 `Entry`，就会创建新的Entry替 换 `table[stableSlot]` 的位置\n- 最后进行过期数据的清理\n\n### ThreadLocalMap.expungeStaleEntry() 原理解析\n> `int staleSlot`：空 slot 的起始位置\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // staleSlot 即为过期 Entry 的起始位置\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    Entry e;\n    int i;\n    // 从起始位置开始向后遍历\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 为null\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        // key 不为 null\n        } else {\n            // 判断位置是否偏离\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                // 位置偏离重新计算位置\n                tab[i] = null;\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n- 将起始位置的 `Entry` 设置为 `null` ，并减小数组中元素的个数。\n- 从起始位置开始向后遍历 `Entry` 数组：\n    - 如果遇到 `key` 为 `null` 的 `Entry` ，那么就把当前的 `Entry` 设置为 `null` ，并且减小数组中元素的个数，然后继续往后探测。\n    - 如果碰到 `key` 不为空的 `Entry` （记作 e ），那么就会重新计算当前 `key` 对应的索引位置（记作 h ），如果与原先的索引位置（也就是当前的 i 值）发生偏离，那么就会将 `i` 对应的 `Entry` 设置为 `null` ，然后重新计算 `e` 的位置。\n    - 如果碰到空的 `slot`  则结束清理，返回空 `slot` 的位置。\n\n### ThreadLocalMap.cleanSomeSlots() 原理解析\n> `int i`：当前 Entry 的位置 <br>\n> `int n`：在插入元素时调用，这个参数代表元素的个数；在 replaceStaleEntry 中调用，这个参数代表数组的长度 。\n``` java\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n- 从当前 Entry 开始向后遍历，遍历 log2(n)  个元素\n- 遇到 key 为null 的Entry 则调用 expungeStaleEntry 进行清理\n\n### ThreadLocalMap 扩容机制\n在set方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值就会执行rehash()\n\n#### rehash 方法\n``` java\nprivate void rehash() {\n    expungeStaleEntries();\n\n    // 数组中的元素个数是否大于 threshold * 3/4\n    if (size >= threshold - threshold / 4)\n        resize();\n}\n```\n- 首先会调用 `expungeStaleEntries` 方法对 `Entry` 数组进行过期数据的清理\n- 然后判断当前数组中的元素个数是否大于 threshold * 3/4 ，如果大于那么就会调用 resize 方法进行扩容\n\n#### resize 方法\n\n``` java\nprivate void resize() {\n    Entry[] oldTab = table;\n    // 旧容量\n    int oldLen = oldTab.length;\n    // 新容量\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n    for (Entry e : oldTab) {\n        if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n            } else {\n                // 重新计算hash\n                int h = k.threadLocalHashCode & (newLen - 1);\n                // hash 冲突则往后查找\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                newTab[h] = e;\n                count++;\n            }\n        }\n    }\n    // 重新计算扩容阈值\n    setThreshold(newLen);\n    size = count;\n    table = newTab;\n}\n```\n- 扩容后的 `Entry` 数组的长度变为旧容量的 `2` 倍\n- 然后去遍历旧的 `Entry` 数组，重新计算 `hash` 位置，然后放到新的 `Entry` 数组中，如果出现 `hash` 冲突则往后寻找最近的 `Entry` 为 `null` 的槽位，遍历完成之后，旧数组中所有的 `Entry` 数据都已经放入到新的 `Entry` 数组中。最后重新计算数组的扩容阈值。\n\n### ThreadLocalMap.getEntry() 原理解析\n> `ThreadLocal<?> key` ：当前key\n```java\nprivate Entry getEntry(ThreadLocal<?> key) {\n    // 获取索引\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    // 命中则直接返回\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n根据 `key` 的 `hash` 获取对应的 `Entry`，如果当前 `Entry` 的 `key` 等于查找的 `key` 那就返回当前 `Entry`，否则就调用 `getEntryAfterMiss` 方法。\n\n### ThreadLocalMap.getEntryAfterMiss() 原理解析\n当 `key` 在其直接哈希槽中找不到时使用\n> `ThreadLocal<?> key` : ThreadLocal 对象 <br>\n> `int i` : ThreadLocal 对应的 hash 值 <br>\n> `Entry e` : ThreadLocal 对应的 Entry\n``` java\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n- 如果当前 `key` 对应的 `Entry` 不为空\n    - 判断当前 `Entry` 的 `key` 是否等于获取的 `key` ，是的话那么就返回当前的 `Entry`。\n    - 如果当前 `Entry` 的 `key` 为 `null` 那么就会调用 `expungeStaleEntry` 方法来清理，接着继续往后迭代。\n- 如果当前 `key` 对应的 `Entry` 为空就直接返回 `null`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '[\"文章\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221088886786, 'C++ 学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"C++\",\"教程\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221088886787, '数据库学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"数据库\",\"教程\",\"MySQL\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221093081089, '小程序开发学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"小程序\",\"教程\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221093081090, '计算机基础学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"计算机基础\",\"教程\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221097275393, '软件工程学习路线 by 程序员鱼皮', '<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>', '[\"文章\",\"学习路线\",\"软件开发\",\"教程\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
INSERT INTO `post` VALUES (1645753221097275394, '企业项目研发流程', '大家好，我是鱼皮。\n\n很多未工作过的小伙伴都很好奇：企业中做项目是怎样的流程？尤其是大厂那些百万用户的项目，和自己学编程时做项目到底有什么区别呢？\n\n**实话说，区别可大了！**\n\n自己开发项目那是单打独斗，自己掌握命运，不会拖垮队友；但企业中开发项目是开团打本，大家是一根绳上的蚂蚱，每个人都会影响整个项目。\n\n![](https://qiniuyun.code-nav.cn/image-20210712012036685.png)\n\n我自己也在几家公司实习过，不得不说，大厂和其他公司的研发流程也有很大的区别。\n\n因此，对于大多数同学，如果没有在大厂工作过，对很多研发环节可能都是一无所知的。\n\n所以今天给大家揭秘一下大厂的项目研发流程，帮大家开拓思路。\n\n正好之前有同志质疑我的日常工作就只有写代码和摸鱼？！这篇文章就作为回击，让他明白，在大厂做项目，可不止写代码那么简单！\n\n![](https://qiniuyun.code-nav.cn/image-20210712011545940.png)\n\n注意：这篇文章更侧重于理论知识，鱼皮曾经在星球直播带大家以实践的方式系统学习团队合作开发项目的方法，保证大家都能上线自己的项目，可以看下 [星球项目训练营](https://t.zsxq.com/0cg8VKgdC) 。如果还未加入星球，欢迎 [加入编程导航知识星球](https://yupi.icu/) 。\n\n本文视频版：https://www.bilibili.com/video/BV11q4y1T7kY\n\n\n\n## 大厂研发流程揭秘\n\n为了规范团队、保证项目的进展，大厂研发流程通常还是比较复杂的。\n\n可以分为很多个阶段，用一张思维导图来概括：\n\n![一线大厂研发流程导图](https://qiniuyun.code-nav.cn/%E4%B8%80%E7%BA%BF%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E6%8F%AD%E7%A7%98.png)\n\n> 需要注意的是，以上阶段并不是完全按从上到下的顺序执行，阶段间可能存在交叉，比如 **技术选型** 其实在 **设计阶段** 就应该考虑。\n\n\n\n正式工作一年多，我也是经历过多次项目的完整研发流程的。下面就以我的视角，带大家快速过一遍~\n\n（为了内容更有趣，以下故事有虚构成分）\n\n\n\n### 需求阶段\n\n今天是周一，鱼皮像往常一样骑着他的小电动车来到公司，殊不知，等待他的是一场噩梦的开始。\n\n\n\n#### 需求产生\n\n上午十点，产品妹子找到鱼皮，告诉他：咱们的系统上线后，用户表示很多功能并不好用，需要大改。\n\n老板也找到鱼皮，告诉他：我今天打开页面竟然加载了十几秒，咱们这个系统的性能太烂了吧！\n\n鱼皮心想：呕豁，完蛋！估计得做个新的项目了，又要开会了。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141645333.png)\n\n果然，没过多久，屏幕上弹出了一条 “欢迎加入会议” 的邀请。\n\n\n\n#### 需求评审\n\n第二天上午，老板、产品、测试、几位开发大哥和鱼皮一起来到会议室，具体讨论昨天提到的那些需求 **是否合理、要不要做** ？\n\n产品妹子打开文档，说到：这一期呢，我们要做这几个需求，下面我来详细讲一下，大家一起评估下有没有问题。\n\n\n\n#### 需求分析\n\n接下来，产品妹子正在对着屏幕侃侃而谈、疯狂输出时，旁边的开发大哥坐不住了。\n\n开发大哥：这个需求不合理啊！\n\n产品：为啥不合理？用户就是有这个需求啊！\n\n开发大哥：我知道，实现不了啊！\n\n于是开始了经典的产品开发撕逼大战。。。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141444097.png)\n\n而鱼皮正躲在角落冷静分析 **这个需求怎么做** ，过了一会儿，提出了一种改动低、实现快的解决方案，平息了这场战争。\n\n\n\n#### 排期\n\n确定需求合理、可实现之后，产品妹子问到：那这个需求啥时候能上线呀？\n\n开发大哥：我这周忙，下周吧。\n\n产品：用户可能比较着急，这周就要呢！\n\n开发大哥：我知道，做不完啊！\n\n于是开始了经典的产品开发撕逼大战。。。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141336633.png)\n\n鱼皮：要不我们把这个需求拆解为功能 A 和功能 B，这周我先把功能 A 做了，功能 B 排到下周二测试，下周四上线？\n\n就这样，我们一个个安排了需求的计划完成日期。\n\n\n\n### 设计阶段\n\n终于开完会了，看了下时间，都该下班了！\n\n唉，需求讨论完了，产品的工作是完成了一些，可鱼皮的工作才刚刚开始。\n\n急着开始写代码么？\n\n**不，想好怎么写代码比写代码更重要。**\n\n\n\n#### 架构设计\n\n鱼皮打开写文档软件和画图软件，开始梳理整个系统，从整体到局部，依次设计出系统的层次结构、各层间交互的接口和通讯方式、每层之间包含哪些重要模块、模块选择何种物理部署方式等。\n\n![知名框架 Dubbo 的架构设计](https://qiniuyun.code-nav.cn/693275-20180308155215280-770422402.png)\n\n\n\n#### 概要设计\n\n写完架构设计后，鱼皮开始对着产品妹子写的 PRD（产品需求文档），分析需求，然后依然是从整体到局部，先整理出系统需要的功能模块，再分析每个功能模块内有哪些子模块。\n\n和抽象的架构设计相比，概要设计和需求的关系更紧密，是对架构设计的细化。\n\n打个比方大家就明白了，你要盖一栋楼，架构设计就是从整体来考虑，总共有几层、每层管道怎么接、每层有几户、地基怎么打等；而概要设计就是考虑每户套件的内部怎么划分，哪里是客厅、哪里是卫生间。\n\n\n\n> 很多情况下，概要设计和架构设计可能会在一个文档中进行，划分并不明确。\n\n\n\n#### 详细设计\n\n想好系统有哪些功能后，鱼皮就开始具体分析每个功能如何实现，用到哪些算法、需要注重哪些细节等。\n\n\n\n#### 方案对齐\n\n写好设计文档后，下次会议上，鱼皮和其他的开发同学（前端、后端等）一起针对自己设计的方案展开讨论，最终产生一个统一的方案，然后大家分工去做就好了。\n\n\n\n#### 测试用例设计\n\n为了保证系统功能的正常稳定，测试同学（或者叫 QA）是非常重要的，测试不是像我们自己做项目一样对着网页点几下就 ok 了。\n\n在大公司中，为了保证测试的覆盖度、提高测试效率，一般是要设计测试用例的，比如：用户点击 “登录”，未传任何数据，期望结果是警告用户输入用户名和密码。\n\n![测试用例管理](https://qiniuyun.code-nav.cn/product-content-testcase-1X3-12439a68c4.png)\n\n测试用例设计完后，需要其他同学一起来评审把关，而不是只交给测试同学。因为一个人很容易忽略掉很多测试细节，最好让更熟悉代码的开发同学一起帮忙补充。\n\n鱼皮自己也写了几个测试可能会遗漏的用例，和测试同学一起进行了确认，尽量让问题暴露在测试阶段而不是线上。\n\n\n\n### 研发准备\n\n写了快一周的设计文档，终于准备开始动手搭建项目了。但在此之前，还有一些准备工作要进行。\n\n\n\n#### 技术预研\n\n如今技术发展太快，新技术层出不穷，所以鱼皮首先对项目中需要或可能需要用到的技术进行了调研。\n\n\n\n#### 技术选型\n\n通过调研，鱼皮得到了几个可以满足需求的技术，但他开始纠结：这么多技术，我该用哪一个呢？是用 SSM 框架还是 Play 框架呢？用 guava 包还是 Apache Commons 呢？\n\n鱼皮又打开了写文档软件，开始对比不同技术的优劣，头疼啊，技术选型要考量的因素太多了，比如：\n\n- 单从技术考虑：性能、易用性、稳定性、主流程度和生态、文档详细度\n- 结合团队：团队成员对技术的熟悉度、掌控度（有无精通该技术的人）\n- 结合业务：是否适应业务的量级（单机 or 微服务）、是否适应业务（读多、写多 or 分析多）\n\n\n\n对于关键的项目，鱼皮自己还不敢完全确定选型，因此在写好自己的选型文档后，与同事和 Leader 一起讨论，才最终确认。\n\n\n\n#### 资源申请\n\n确认好技术后，就要申请资源。比如鱼皮用到了 MySQL 数据库，但是这个 MySQL 从哪儿来呢？\n\n以前的话，鱼皮都是去买一台云服务器，自己搭建 MySQL。但是在企业中，一般是有集中管理和分配资源的平台的，直接到平台填写预算、等领导审批、然后等着下发资源就好了。千万不能私自用自己的或买外部的服务器来部署项目，不安全！\n\n鱼皮这次直接申请到了 2 万多一年的云数据库，真的是爽死了。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140804895.png)\n\n\n\n#### 环境准备\n\n申请好数据库等资源后，鱼皮按照申请机器的版本搭建了一模一样的本地开发环境和测试环境，后面就可以直接连接了。\n\n\n\n#### 项目初始化\n\n环境准备妥当后，由于是新项目，鱼皮要搞一个最小可运行的初始化项目 Demo，使用 **脚手架** 自动生成代码，而不是从零开始一个个新建文件、手敲重复代码。\n\n\n\n#### 依赖安装\n\n生成了项目代码后，鱼皮使用包管理工具（前端 yarn、Java Maven /  Gradle 等）自动安装依赖，然后项目 Demo 就可以运行啦！\n\n\n\n### 研发阶段\n\n前期准备完成后，这才到了程序员朋友们最熟悉的写代码环节，也是鱼皮最爱的环节。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140724830.png)\n\n因为之前设计方案时需要保持冷静、仔细思考，没法边听歌儿边做；而方案设计好后，已经明确了该怎么做，写代码实现就很简单了，顶多是遇到一些坑，上网搜索去解决就好了。\n\n\n\n#### 本地开发\n\n开发时，一般鱼皮会先在本地写代码，通过配置热更新工具，实现代码更新时自动重新编译打包，而不用手动重启项目，大大提高了开发效率。\n\n对了，企业开发都会使用版本控制系统的，比如 Git，开发前记得先创建一个自己的分支，在这个分支上开发。\n\n\n\n#### 远程开发\n\n现在还有一种比较流行的远程开发方式，就是可以像编辑本地文件一样编辑远程文件，直接修改服务器上的代码。一般我们每位研发同学是有自己的开发机的，通过远程开发就省去了反复部署调试的麻烦，提高效率。一般用 VSCode 等开发工具，安装远程开发插件就可以实现了。\n\n\n\n#### 代码优化\n\n鱼皮在写代码的时候，始终保持主动优化代码的好习惯，注重代码的时空复杂度；并且当重复代码多了，会想办法抽象成函数或者使用设计模式。之前专门写文章分享过我的编程习惯：[我写代码时的小倔强](https://mp.weixin.qq.com/s/df5JMmBbw294y2sAPMwGbA) 。\n\n\n\n#### 单元测试\n\n注意！不要听到测试就以为是测试同学的工作，开发同学也同样需要编写小粒度的测试来为自己的代码负责。\n\n鱼皮一般会为每个数据库读写函数和业务逻辑函数编写单元测试，像 Java 的话一般用 JUnit 等工具，还可以用 Jacoco 生成测试覆盖度报告。每次修改关键代码后，都要执行一遍单元测试，防止意外错误。\n\n![Jacoco 测试覆盖度报告](https://qiniuyun.code-nav.cn/image-20210712140554038.png)\n\n\n\n#### 开发联调\n\n鱼皮终于写好了后端代码，也自测完成了，下面就是把写好的代码打包构建，然后把可执行项目包发布到测试服务器上，和前端同学一起联调，让他请求我的接口，验证系统的功能是否可用。\n\n\n\n### 测试验证\n\n鱼皮和前端联调完毕后，告知了测试和产品同学。\n\n测试验证是企业中至关重要的环节，甚至可以说是最后一道防线。测试的目的是找 Bug，尽量发现系统中的问题，把它们扼杀在测试阶段。\n\n在企业中，测试验证又有很多类型。\n\n\n\n#### 集成测试\n\n集成测试比单元测试粒度更大，是把多个模块或代码单元放在一起，验证模块之间的集成和调用关系。\n\n因为单个函数的执行可能是正常的，但把多个函数组合在一起顺序调用，可能就会出现问题。\n\n打个比方，我们有个吃面包系统：\n\n功能 A：小鱼吃一个面包\n\n功能 B：小皮吃一个面包\n\n每次只有一个面包，独立执行功能 A 和 B 都是允许的。但如果两个一起执行，后执行的那个功能就会报错。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140428508.png)\n\n\n\n#### 系统测试\n\n系统测试比集成测试的粒度更大，测试对象是整个系统，不仅包括软件，还可能覆盖对硬件的测试。\n\n\n\n#### 产品体验\n\n除了测试同学要验证系统可用性，产品妹子也要体验下功能是否符合预期、是否易用。大多数情况下，产品会在体验时提出修改建议，开发可能还要再去做一些修改。\n\n\n\n#### 验收测试\n\n测试和产品妹子终于表示没有问题啦，那就到了最后一步，把整个产品或功能给最终的用户来体验。~~老板~~ 用户说没问题，才是真的没问题！\n\n\n\n### 提交阶段\n\n系统没问题之后，鱼皮就可以把代码发布到远程仓库了，一般使用 Git 和 SVN 等版本控制系统。\n\n\n\n#### 代码提交\n\n鱼皮首先在本地触发代码提交（git commit），为保证规范，在大项目中一般会使用提交检测插件，防止你把错误的代码进行了提交。\n\n\n\n#### 代码推送\n\n下一步就是把本地的提交推送到远程的同名分支。一般大厂会有推送检测工具，检测代码的错误、圈复杂度、代码规范等，和提交检测一样，防止你把错误或不规范的代码进行了推送。\n\n\n\n#### 合并请求\n\n代码分支推送到远程之后，鱼皮发起了一个分支合并请求（MR），希望把该分支的代码合并到主干分支（没问题的代码）。\n\n![发起新合并请求](https://qiniuyun.code-nav.cn/image-20210712140308463.png)\n\n#### 代码审查\n\n并不是发起了合并请求就能直接合并，还要通过代码审查，即 CR。\n\n审查又分为两种方式：人审和机审。\n\n相信不少同学都知道人审，一般是由你的上级和其他项目负责人来阅读和评论你的代码，觉得没问题就 Approve（通过），否则打回去修改。\n\n那机审是个啥呢？其实就是机器自动检测你的代码是否符合规范，是否能够成功自动化构建等，一般是由项目负责人配置的，可以帮助发现一些人工难以发现的问题。\n\n刚接触新项目的时候，鱼皮经常被机审折磨得苦不堪言，经常被提示一些莫名其妙的代码问题，比如加号要换行，文件行末要加空行等。但后来注意编码习惯后，就很自然地适应了，的确不错。\n\n\n\n### 发布阶段\n\n代码审查通过后，鱼皮的项目代码就可以发布上线啦。\n\n![](https://qiniuyun.code-nav.cn/image-20210613143744811.png)\n\n\n\n#### 打包构建\n\n传统上线方式是开发人员到正式服务器上拉取代码，然后安装依赖，再通过工具把代码打包构建，得到部署包，通过 Nginx、Tomcat、Docker 等技术运行。\n\n但这样效率很低，有很多重复工作。所以大厂一般是用自动化构建的，像 Jenkins、各种 CI / CD 工具等。代码合并到主分之后，由机器把代码打包构建为最终的部署包。\n\n\n\n#### 预发布\n\n为了防止上线出问题，一般我们会先在预发布环境部署项目，再观察一下是否能够正常运行。\n\n\n\n#### 正式发布\n\n预发布测试正常后，鱼皮终于等到了上线的这一刻。大项目一般都会部署在多台机器上，所以不可能一台台登录机器去发布部署包。\n\n通常公司会提供可视化发布平台，点选需要发布机器（一般先灰度，选一小部分机器，再全量发布），点击一键发布，等项目管理员审批通过之后，就交给机器自动部署吧！\n\n\n\n### 后续\n\n鱼皮曾天真地以为项目上线之后，就可以高枕无忧了。但后来发现，项目上线之后，同样需要保持警觉。虽然已经测试过，但仍然时不时会出现个预期之外的小 Bug，还是很考验心态的。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140135097.png)\n\n来看看上线之后，鱼皮做了哪些事呢？\n\n\n\n#### 监控运维\n\n鱼皮会定期查看项目的监控面板，观察项目的运行情况，机器的负载等。\n\n\n\n#### 统计分析\n\n鱼皮在代码中添加了一些日志，可以利用 ELK 等日志收集可视化平台对这些日志进行分析，从而感知到用户的行为，进一步优化业务和系统。\n\n比如我会统计用户执行 SQL 查询的耗时，对重复率高的慢 SQL 进行针对性地优化。\n\n\n\n#### 事件反馈\n\n有的时候，用户自己都不能清楚地描述 Bug，而且历史 Bug 也不方便找到。所以公司内部一般会有事件反馈平台，产品等内部同学在接收到 Bug 时，会在该平台发布一个 Bug 事件，详细描述 Bug 出现的时间、状况、详情等，便于我们开发集中分析和处理问题。\n\n![事件反馈平台](https://qiniuyun.code-nav.cn/image-20210712140028393.png)\n\n\n\n#### 文档沉淀\n\n每次上线了新功能和项目，鱼皮都会通过写文档来记录项目的背景、设计方案、开发过程和一些坑点，便于后续其他同学了解项目，这是非常重要的！利人利己。\n\n曾经分享过我的写文档技巧：[如何写好文档？](https://mp.weixin.qq.com/s/oQTksFE-cPYRKGJnr71-kw)\n\n\n\n#### 迭代优化\n\n最后，一个需求的结束往往只是另一个需求的开始。像鱼皮最近在跟进的项目，一期做完做二期，二期还没做完三期就来了；还要抽出时间去优化以前的代码，这日子遥遥无期，没盼头啊！\n\n\n\n---\n\n\n\n看完本文后，欢迎阅读我之前的这篇文章：[大厂机密！30 个提升团队研发效能的锦囊](https://mp.weixin.qq.com/s/RyqO8ry29zAL40ToVitxTQ) ，了解更多大厂技术。\n\n', '[\"文章\",\"学习路线\",\"软件开发\",\"教程\"]', 0, 0, 1, '2023-04-11 19:38:39', '2023-04-11 19:38:39', 0);
COMMIT;

-- ----------------------------
-- Table structure for post_favour
-- ----------------------------
DROP TABLE IF EXISTS `post_favour`;
CREATE TABLE `post_favour` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `postId` bigint NOT NULL COMMENT '帖子 id',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_postId` (`postId`),
  KEY `idx_userId` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='帖子收藏';

-- ----------------------------
-- Records of post_favour
-- ----------------------------
BEGIN;
INSERT INTO `post_favour` VALUES (1, 1645612297423745026, 1641693136519720961, '2023-04-11 10:20:28', '2023-04-11 10:20:28');
COMMIT;

-- ----------------------------
-- Table structure for post_thumb
-- ----------------------------
DROP TABLE IF EXISTS `post_thumb`;
CREATE TABLE `post_thumb` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `postId` bigint NOT NULL COMMENT '帖子 id',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_postId` (`postId`),
  KEY `idx_userId` (`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='帖子点赞';

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `userAccount` varchar(256) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '账号',
  `userPassword` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密码',
  `unionId` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信开放平台id',
  `mpOpenId` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '公众号openId',
  `userName` varchar(256) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户昵称',
  `userAvatar` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户头像',
  `userProfile` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '用户简介',
  `userRole` varchar(256) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'user' COMMENT '用户角色：user/admin/ban',
  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  KEY `idx_unionId` (`unionId`)
) ENGINE=InnoDB AUTO_INCREMENT=1645747333158510595 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户';

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1641693136519720961, 'yexd', 'b0dd3697a192885d7c055db46155b26a', NULL, NULL, 'xdye', NULL, 'testProfile', 'user', '2023-03-31 14:45:19', '2023-04-11 13:03:51', 0);
INSERT INTO `user` VALUES (1645747333158510594, 'xxxdqwe', '1b8956eb700e9a5cb9ca7d960ba6b5b6', NULL, NULL, 'qwe', NULL, 'testprofile', 'user', '2023-04-11 19:15:15', '2023-04-13 07:46:54', 0);
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
